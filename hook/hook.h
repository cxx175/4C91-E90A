#ifndef HOOK_H#define HOOK_H#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/mman.h>#include <unistd.h>#include <dlfcn.h>// 使用标准输出替代 Android 日志#define LOGI(...) printf("[INFO] " __VA_ARGS__); printf("\n")#define LOGE(...) printf("[ERROR] " __VA_ARGS__); printf("\n")// 定义页大小#define PAGE_SIZE 4096// Hook 结构体typedef struct {    void* target_addr;     // 目标函数地址    void* new_addr;        // 新函数地址    unsigned char backup[12]; // 原始代码备份(ARM 需要 12 字节)    int is_hooked;         // 是否已经 hook} HookInfo;// 修改内存权限static int modify_memory_protection(void* addr) {    long page_size = sysconf(_SC_PAGESIZE);    void* page_addr = (void*)((long)addr & ~(page_size - 1));    return mprotect(page_addr, page_size, PROT_READ | PROT_WRITE | PROT_EXEC);}// Hook 函数static int hook_function(void* target_func, void* new_func, HookInfo* hook_info) {    if (!target_func || !new_func || !hook_info) {        LOGE("Hook 参数错误");        return -1;    }        // 保存原始信息    hook_info->target_addr = target_func;    hook_info->new_addr = new_func;    hook_info->is_hooked = 0;        // 修改内存权限    if (modify_memory_protection(target_func) != 0) {        LOGE("修改内存权限失败");        return -1;    }        // 备份原始代码    memcpy(hook_info->backup, target_func, sizeof(hook_info->backup));        // ARM 跳转指令    unsigned char jump_code[] = {        0x04, 0xF0, 0x1F, 0xE5,     // LDR PC, [PC, #-4]        0x00, 0x00, 0x00, 0x00      // 目标地址    };        // 写入新函数地址    *(void**)(jump_code + 4) = new_func;        // 写入跳转代码    memcpy(target_func, jump_code, sizeof(jump_code));        hook_info->is_hooked = 1;    LOGI("Hook 成功: %p -> %p", target_func, new_func);    return 0;}// 取消 Hookstatic int unhook_function(HookInfo* hook_info) {    if (!hook_info || !hook_info->is_hooked) {        LOGE("取消 Hook 参数错误");        return -1;    }        // 修改内存权限    if (modify_memory_protection(hook_info->target_addr) != 0) {        LOGE("修改内存权限失败");        return -1;    }        // 恢复原始代码    memcpy(hook_info->target_addr, hook_info->backup, sizeof(hook_info->backup));        hook_info->is_hooked = 0;    LOGI("取消 Hook 成功: %p", hook_info->target_addr);    return 0;}// 查找符号地址static void* find_symbol(const char* library, const char* symbol) {    void* handle = dlopen(library, RTLD_NOW);    if (!handle) {        LOGE("无法加载库: %s, 错误: %s", library, dlerror());        return NULL;    }        void* addr = dlsym(handle, symbol);    if (!addr) {        LOGE("无法找到符号: %s, 错误: %s", symbol, dlerror());        dlclose(handle);        return NULL;    }        LOGI("找到符号 %s 地址: %p", symbol, addr);    return addr;}#endif // HOOK_H 